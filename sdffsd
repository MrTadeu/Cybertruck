#include <hardware_interface/system_interface.hpp>
#include <hardware_interface/types/hardware_interface_return_values.hpp>
#include <rclcpp/rclcpp.hpp>
#include <pluginlib/class_list_macros.hpp>
#include <libserial/SerialPort.h>
#include <vector>
#include <string>
#include <iostream>

using CallbackReturn = rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn;

namespace my_robot_hardware
{
class MyRobotHardwareInterface : public hardware_interface::SystemInterface
{
public:
    CallbackReturn on_init(const hardware_interface::HardwareInfo &info) override
    {
        if (hardware_interface::SystemInterface::on_init(info) != CallbackReturn::SUCCESS)
        {
            return CallbackReturn::ERROR;
        }

        joint_positions_.resize(info.joints.size(), 0.0);
        joint_velocities_.resize(info.joints.size(), 0.0);
        joint_commands_.resize(info.joints.size(), 0.0);

        serial_port_ = "/dev/ttyUSB0"; // Default serial port
        baud_rate_ = 115200;          // Default baud rate

        try
        {
            serial_connection_.Open(serial_port_);
            serial_connection_.SetBaudRate(LibSerial::BaudRate::BAUD_115200);
        }
        catch (const LibSerial::OpenFailed &e)
        {
            RCLCPP_FATAL(rclcpp::get_logger("MyRobotHardwareInterface"), "Unable to open serial port: %s", e.what());
            return CallbackReturn::ERROR;
        }

        return CallbackReturn::SUCCESS;
    }

    std::vector<hardware_interface::StateInterface> export_state_interfaces() override
    {
        std::vector<hardware_interface::StateInterface> state_interfaces;
        for (size_t i = 0; i < joint_positions_.size(); i++)
        {
            state_interfaces.emplace_back(hardware_interface::StateInterface(
                info_.joints[i].name, "position", &joint_positions_[i]));
            state_interfaces.emplace_back(hardware_interface::StateInterface(
                info_.joints[i].name, "velocity", &joint_velocities_[i]));
        }
        return state_interfaces;
    }

    std::vector<hardware_interface::CommandInterface> export_command_interfaces() override
    {
        std::vector<hardware_interface::CommandInterface> command_interfaces;
        for (size_t i = 0; i < joint_commands_.size(); i++)
        {
            command_interfaces.emplace_back(hardware_interface::CommandInterface(
                info_.joints[i].name, "velocity", &joint_commands_[i]));
        }
        return command_interfaces;
    }

    hardware_interface::return_type read(const rclcpp::Time &time, const rclcpp::Duration &period) override
    {
        if (serial_connection_.IsDataAvailable())
        {
            std::string feedback;
            serial_connection_.ReadLine(feedback, '\n');
            RCLCPP_INFO(rclcpp::get_logger("MyRobotHardwareInterface"), "Feedback: %s", feedback.c_str());
            // Parse feedback and update joint_positions_ and joint_velocities_
        }
        return hardware_interface::return_type::OK;
    }

    hardware_interface::return_type write(const rclcpp::Time &time, const rclcpp::Duration &period) override
    {
        std::string command;
        for (size_t i = 0; i < joint_commands_.size(); i++)
        {
            command += std::to_string(joint_commands_[i]) + ",";
        }
        if (!command.empty())
        {
            command.pop_back(); // Remove trailing comma
        }
        serial_connection_.Write(command + "\n");
        return hardware_interface::return_type::OK;
    }

private:
    std::vector<double> joint_positions_;
    std::vector<double> joint_velocities_;
    std::vector<double> joint_commands_;
    std::string serial_port_;
    int baud_rate_;
    LibSerial::SerialPort serial_connection_;
};

} // namespace my_robot_hardware

PLUGINLIB_EXPORT_CLASS(my_robot_hardware::MyRobotHardwareInterface, hardware_interface::SystemInterface)
